// Сообщения, посылаемые окнам при выполнении различных функций
#define CHANGE_TITLE        1
#define CHANGE_CONTENT      2
#define CHANGE_COMPONENT    3
#define PUT_ATTRIBUTE       4
#define INS_ATTRIBUTE       5
#define DEL_ATTRIBUTE       6
#define PUT_VALUE           7
#define INS_VALUE           8
#define DEL_VALUE           9
#define INS_RULE            10                              // Не используется
#define DEL_RULE            11
#define INS_PROP            12
#define DEL_PROP            13
#define INVERT_PROP         14

#define STAT_GENERATION     1
#define STAT_ABSORPTION     2

typedef BOOL (FAR PASCAL *COMPILEOUT) ( int, int, int, int, int );

typedef struct {
		unsigned char nec, pos;
		}             COMP;                         // Компонента высказывание
typedef COMP FAR     *LPCOMP;

/*
┌────────────────────────────────────────────────────────────────┬───────────┐
│ Структура описания модуля. То что может менять пользователь.   │ MOD_DESCR │
│                                                                └───────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
struct MOD_DESCR {
	char       Name[128];                                   // Название модуля
	char       Question[128];                             // Вопрос для модуля
	char       Comment[1024];                            // Комментарий модуля
	char       IconFile[80];                             // Файл иконки модуля
	char       HyperFile[80];                              // Файл гипертекста
	DWORD      HyperIndex;                      // Индекс модуля в гипертексте
	};

class FAR KBFILE;
typedef KBFILE FAR   *LPKBFILE;

class FAR KBASE;
typedef KBASE FAR  *LPKBASE;

struct HEAD_REC;
typedef HEAD_REC FAR  *LPHEAD_REC;

struct MOD_DESCR;
typedef MOD_DESCR FAR  *LPMOD_DESCR;

struct ATT_REC;
typedef ATT_REC FAR  *LPATT_REC;

struct VAL_REC;
typedef VAL_REC FAR  *LPVAL_REC;

struct ATT_IDX;
typedef ATT_IDX FAR  *LPATT_IDX;

struct VAL_IDX;
typedef VAL_IDX FAR  *LPVAL_IDX;

struct HEAD_RUL;
typedef HEAD_RUL FAR  *LPHEAD_RUL;

struct HEAD_PROP;
typedef HEAD_PROP FAR  *LPHEAD_PROP;

extern unsigned char UNITY;

/*
┌───────────────────────────────────────────────────────────────────┬────────┐
│ Для каждого открытого файла БЗ создается ровно один объект.       │ KBFILE │
│                                                                   └────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#define BUF_SIZE             32000
#define PATHLENGTH           80

class FAR KBFILE {
public:
	static int      Error;
	static LPKBFILE lpFirstKBFile;
	static LPKBFILE lpLastKBFile;

	LPKBFILE   lpNextKBFile;
	LPKBFILE   lpPrevKBFile;

	// В каждом объекте KBFILE поддерживается список объектов KBASE
	LPKBASE    lpFirstKBase;                            // Первый элемнт KBASE
	LPKBASE    lpLastKBase;                          // Последний элемнт KBASE

	MOD_DESCR  ModDescr;                                    // Описание модуля

	char       KBFilePath[PATHLENGTH];                              // путь БЗ
	char       KBFileName[13];                                       // имя БЗ
	int        isChanged;

	int        numAtt;                                 // Количество атрибутов
	int        numAllVal;                          // Количество всех значений

	int        numRul;                           // Количество исходных правил
	int        numCon;                          // Количество конъюнктов в ДНФ
	int        numDis;                          // Количество дизъюнктов в КНФ

	long       lenRul;                                    // Длина всех правил
	long       lenDNF;                          // Длина ДНФ (всех конъюнктов)
	long       lenCNF;                          // Длина КНФ (всех дизъюнктов)

	int        isDNF;                                 // Скомпилирована ли ДНФ
	int        isCNF;                                 // Скомпилирована ли КНФ

	LPATT_IDX  lpAttIdx;                      // Указатель на индекс атрибутов
	LPVAL_IDX  lpValIdx;                       // Указатель на индекс значений
	LPHEAD_RUL lpRul;                                  // Указатель на правила
	LPHEAD_RUL lpData;                                  // Указатель на данные
	LPHEAD_RUL lpConc;                                  // Указатель на выводы

	LPHEAD_RUL lpDNF;                                      // Указатель на ДНФ
	LPHEAD_RUL lpCNF;                                      // Указатель на КНФ

// Функции манипулирования объектом

	static LPKBFILE OpenKBFile ( LPSTR );                       // Открыть файл
	int            CloseKBFile ( void );                       // Закрыть файл
	int            SaveKBFile ( void );                        // Сохранить БЗ
	int            RenameKBFile ( LPSTR );             // Дать новое имя файлу
	void           ResetCNF ( void );                          // Сбросить КНФ
	void           ResetDNF ( void );                          // Сбросить ДНФ

	BOOL           isKBFileNamed ( void );                  // Именована ли БЗ
	BOOL           isKBFileSaved ( void );                  // Сохранена ли БЗ
	static LPKBFILE isAlreadyOpened ( LPSTR );             // Открыта ли уже БЗ

// Функции сортировки

	void       SortAttributes ( void );              // Отсортировать атрибуты
	void       SortAllValues ( void );           // Отсортировать все значения
	void       SortValues ( int );   // Отсортировать значения одного атрибута

	int        AttI2N ( int, int );              // Относительный в абсолютный
	int        AttN2I ( int, int );              // Абсолютный в относительный
	int        ValI2N ( int, int, int );         // Относительный в абсолютный
	int        ValN2I ( int, int, int );         // Абсолютный в относительный

	int        Prop2Att ( int, LPHEAD_RUL, int );
	int        Att2Prop ( int, LPHEAD_RUL, int );

// Групповые (списочные) функции

/*	firstThat
	lastThat

	forEach
	forEachKBase */
	void       forEachWindow ( int, DWORD );

	static int KBFilesNumber ( VOID );
	int        KBaseNumber ( VOID );

// Функции манипулирования и доступа к атрибутам

	LPATT_REC  GetAttribute ( int );                       // Получить атрибут
	int        PutAttribute ( int, LPATT_REC );            // Положить атрибут
	int        InsAttribute ( int, LPATT_REC );            // Вставить атрибут
	int        DelAttribute ( int );                        // Удалить атрибут

	int        AttNumber ();                           // Количество атрибутов

// Функции манипулирования и доступа к значениям

	LPVAL_REC  GetValue ( int, int );                     // Получить значение
	int        PutValue ( int, int, LPVAL_REC );          // Положить значение
	int        InsValue ( int, int, LPVAL_REC );          // Вставить значение
	int        DelValue ( int, int );                      // Удалить значение

	int        ValNumber ( int );                       // Количество значений
	int        ValSum ( int );                // Суммарное количество значений
	int        ValSum ( int, int );
	int        ValSum ( int, LPHEAD_RUL, int );

// Функции манипулирования и доступа к правилам (семантические)

	int        RuleNumber ();                        // Количество правил в БЗ
	LPHEAD_RUL GetRuleHead ( int );           // Получить указатель на правило
	int        InsRule ( LPHEAD_RUL );              // Вставить пустое правило
	int        DelRule ( LPHEAD_RUL );                      // Удалить правило

	void       InsAttInKBase ( int );   // Скомпенсировать добавление атрибута
	void       InsAttInDNF ( int );
	void       InsAttInCNF ( int );
	LPHEAD_RUL InsAttInRule ( int, LPHEAD_RUL );

	void       DelAttInKBase ( int );     // Скомпенсировать удаление атрибута
	LPHEAD_RUL DelAttInRule ( int, LPHEAD_RUL );

	void       InsValInKBase ( int, int );       // Скомпенсировать добавление значения
	void       InsValInDNF ( int, int );
	void       InsValInCNF ( int, int );
	LPHEAD_RUL InsValInRule ( int, int, LPHEAD_RUL );
	LPHEAD_RUL InsValInData ( int, int );
	LPHEAD_RUL InsValInConc ( int, int );

	void       DelValInKBase ( int, int );     // Скомпенсировать удаление значения
	LPHEAD_RUL DelValInRule ( int, int, LPHEAD_RUL );
	LPHEAD_RUL DelValInData ( int Att, int Val );
	LPHEAD_RUL DelValInConc ( int Att, int Val );

	int        PropNumber ( LPHEAD_RUL ); // Количество высказываний в правиле
	int        PropNumber ( int );
	LPHEAD_PROP GetPropHead ( LPHEAD_RUL, int );  // Указатель на высказывание
	int        AbsProp2Att ( int, LPHEAD_RUL );
	int        AbsAtt2Prop ( int, LPHEAD_RUL );

	int        InsPropInData ( int, int );            // Вставить высказывание
	int        InsPropInConc ( int, int );
	int        InsPropInRule ( LPHEAD_RUL, int, int );

	int        DelPropInData ( int );                  // Удалить высказывание
	int        DelPropInConc ( int );
	int        DelPropInRule ( LPHEAD_RUL, int );
	int        DelPropInKBase ( int );

	int        InvertProp ( LPHEAD_RUL, int );   // Инвертировать высказывание
	int        InvertComps ( LPHEAD_RUL, int );      // Инвертировать все комп

	LPCOMP     GetComp ( LPHEAD_PROP, int );            // Получить компоненту
	LPCOMP     GetComp ( LPHEAD_RUL, int, int );

	// Логические функции

	BOOL       CompileToCNF ( COMPILEOUT );
	int        DisIntoDis ( LPHEAD_RUL );
	VOID       ReduceDis ( LPHEAD_RUL );
	VOID       ReduceDisTo ( LPHEAD_RUL );
	VOID       ReduceConMax ( LPHEAD_RUL );
	VOID       ReduceConMaxTo ( LPHEAD_RUL );
	VOID       ReduceDisMaxTo ( LPHEAD_RUL );
	VOID       ExtendCon ( LPHEAD_RUL );
	VOID       ExtendDis ( LPHEAD_RUL );
	BOOL       AbsorbLast ( LPHEAD_RUL, int, long );
	BOOL       AbsorbDis ( LPHEAD_RUL, LPHEAD_RUL );
	BOOL       AbsorbConMax ( LPHEAD_RUL, LPHEAD_RUL );
	BOOL       ImposeConMax ( LPHEAD_RUL, LPHEAD_RUL );
	BOOL       ImposeConOnDis ( LPHEAD_RUL, LPHEAD_RUL );
	BOOL       ImposeProjectDisOnCon ( LPHEAD_RUL, LPHEAD_RUL );
	int        ProjectDis ( LPHEAD_RUL, LPCOMP );
	};

/*
┌────────────────────────────────────────────────────────────────────┬───────┐
│ Основной класс для доступа к файлам и функциям LK EDIP.            │ KBASE │
│ При каждом открытии файла БЗ создается один объект этого класса.   └───────┤
│ Содержит данные и выводы.                                                  │
└────────────────────────────────────────────────────────────────────────────┘
*/
#define SORT_UNSORTED        1
#define SORT_ALPHA           2
#define SORT_VALNUM          3
#define SORT_PRICE           4
#define SORT_IMPORTANCE      5
#define SORT_CHARACTER       6
#define SORT_ASINRULE        7

#define VIEW_STRUCT         1
#define VIEW_KNOWLEDGE      2
#define VIEW_DATA           3
#define VIEW_CONCLUSION     4

class FAR KBASE {
public:
	static int Error;

	LPKBASE    lpNextKBase;                    // Указатель на следующий KBASE
	LPKBASE    lpPrevKBase;                   // Указатель на предыдущий KBASE

	LPKBFILE   lpHost;                           // Указатель на объект KBFILE

	int        curAtt;                               // Текущий номер атрибута
	int        curVal;                               // Текущий номер значения
	int        curRul;                      // Текущий номер исходного правила

	LPHEAD_RUL lpRul;                          // Указатель на текущее правило

	int        curAttSort;                     // Текущая сортировка атрибутов
	int        curValSort;                      // Текущая сортировка значений

	int        View;                              // Что просматриватся в окне
	HWND       hWnd;                                         // Окно просмотра

// Функции манипулирования объектом

	static LPKBASE OpenKBase ( LPSTR );                         // Конструктор
	int        CloseKBase ( VOID );                              // Деструктор
	int        SaveKBase ( VOID );                             // Сохранить БЗ
	int        RenameKBase ( LPSTR );                  // Дать новое имя файлу
	int        MoveKBase ( LPKBFILE );           // Передать окно новому файлу

	BOOL       isKBaseNamed ( VOID );                       // Именована ли БЗ
	BOOL       isKBaseSaved ( VOID );                       // Сохранена ли БЗ

	HWND       SetWindow ( HWND );                     // Установить ключ окна
	HWND       GetWindow ( VOID );                       // Получить ключ окна

	int        SetView ( int );                              // Установить вид
	int        GetView ( VOID );                               // Получить вид

	LPSTR      GetNamePtr ( VOID ) { return lpHost->KBFileName; };// Получить указатель на имя файла
	LPSTR      GetPathPtr ( VOID ) { return lpHost->KBFilePath; };// Получить указатель на полный путь файла

	int        GetModuleHead ( LPMOD_DESCR );      // Получить описание модуля
	int        SetModuleHead ( LPMOD_DESCR );     // Сохранить описание модуля

// Групповые (списочные) функции

/*	firstThat
	lastThat

	forEach
	forEachKBase */

	int        KBFilesNumber ( VOID );
	int        KBaseNumber ( VOID );

	LPKBASE    GetFirstKBase ( VOID ) { return lpHost->lpFirstKBase; };
	LPKBASE    GetNextKBase ( VOID ) { return lpNextKBase; }

// Функции манипулирования и доступа к атрибутам

	int        GetAttribute ( int, LPATT_REC );            // Получить атрибут
	int        GetAttribute ( LPATT_REC );
	int        PutAttribute ( LPATT_REC );                 // Положить атрибут
	int        InsAttribute ( LPATT_REC );                 // Вставить атрибут
	int        DelAttribute ( VOID );                       // Удалить атрибут

	int        AttNumber ( VOID ) { return lpHost->numAtt; };    // Количество атрибутов

	int        GetCurAtt ( VOID );                 // Получить текущий атрибут
	int        SetCurAtt ( int );                // Установить текущий атрибут

	int        GetCurAttPos ( VOID );    // Получить позицию атрибута в списке
	int        SetCurAttPos ( int );   // Установить позицию атрибута в списке
	int        NextAttPos ( VOID ) { return SetCurAttPos ( GetCurAttPos() + 1 ); };
	int        PrevAttPos ( VOID ) { return SetCurAttPos ( GetCurAttPos() - 1 ); };

	int        GetAttSort ( VOID );   // Получить текущую сортировку атрибутов
	int        SetAttSort ( int );            // Установить текущую сортировку

	int        Prop2Att ( int );                            // Позиция в номер
	int        Att2Prop ( int );                            // Номер в позицию
	int        Name2Att ( LPSTR );                   // По имени найти атрибут
	BOOL       isAttEnabled ( int );             // Входит ли атрибут в список

// Функции манипулирования и доступа к значениям

	int        GetValue ( int, int, LPVAL_REC );          // Получить значение
	int        GetValue ( LPVAL_REC );
	int        PutValue ( LPVAL_REC );                    // Положить значение
	int        InsValue ( LPVAL_REC );                    // Вставить значение
	int        DelValue ( VOID );                          // Удалить значение

	int        ValNumber ( int );                       // Количество значений
	int        ValNumber ( VOID );

	int        ValPosSum ( int );             // Суммарное количество значений

	int        GetCurVal ( VOID );                // Получить текущее значение
	int        SetCurVal ( int );               // Установить текущее значение
	int        NextVal ( VOID ) { return SetCurVal ( GetCurVal() + 1 ); };
	int        PrevVal ( VOID ) { return SetCurVal ( GetCurVal() - 1 ); };

	int        GetValSort ( VOID );    // Получить текущую сортировку значений
	int        SetValSort ( int );            // Установить текущую сортировку

	// Функции манипулирования правилами
	int        InsRule ( VOID );      // Вставить пустое правило перед текущим
	int        DelRule ( VOID );                    // Удалить текущее правило

	int        RuleNumber ( VOID ) { return lpHost->numRul; };  // Количество правил в БЗ

	int        GetCurRule ( VOID ) { return curRul; };      // Получить номер текущего правила
	int        SetCurRule ( int );        // Установить номер текущего правила
	int        NextRule ( VOID ) { return SetCurRule ( GetCurRule() + 1 ); };// Перейти к следующему правилу
	int        PrevRule ( VOID ) { return SetCurRule ( GetCurRule() - 1 ); };// Перейти к предыдущему правилу

	BOOL       isRuleDisjunct ( VOID );           // Текущее правило дизъюнкт?
	BOOL       SetRuleDisjunct ( BOOL );         // Установить дизъюнктивность

	// Функции манипулирования высказываниями
	int        InsProp ( int );           // Вставить тривиальное высказывание
	int        DelProp ( VOID );               // Удалить текущее высказывание

	int        InvertProp ( int );               // Инвертировать высказывание
	int        InvertProp ( VOID );      // Инвертировать текущее высказывание
	int        InvertComps ( VOID );       // Инвертировать все комп текущего высказывание

	int        PropNumber ( VOID );                 // Количество высказываний

	BOOL       isPropConjunct ( int );               // Высказывание конъюнкт?
	BOOL       SetPropConjunct ( int, BOOL );    // Установить конъюнктивность

	// Функции манипулирования компонентами

	int        GetComp ( int, int, LPCOMP );            // Получить компоненту
	int        SetComp ( int, int, LPCOMP );          // Установить компоненту


	// Логические функции
	int        InferenceCNF ( VOID );
	int        InferencePassCNF ( LPHEAD_RUL, LPHEAD_RUL, LPHEAD_RUL );
	VOID       InferenceDisCNF ( LPHEAD_RUL, LPHEAD_RUL, LPHEAD_RUL );

	VOID       TransferConIntoWindow ( LPHEAD_RUL );

	};

/*
┌─────────────────────────────────────────────────────────────────┬──────────┐
│ Запись-заголовок файла базы знаний                              │ HEAD_REC │
│                                                                 └──────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
struct HEAD_REC {
	char       CopyWrite[80];
	WORD       Version;

	int        numAtt;                                 // Количество атрибутов
	int        numAllVal;                          // Количество всех значений

	int        numRul;                           // Количество исходных правил
	int        numCon;                          // Количество конъюнктов в ДНФ
	int        numDis;                          // Количество дизъюнктов в КНФ

	long       lenRul;                                  // Длина буфера правил
	long       lenDNF;                             // Общая длина ДНФ в байтах
	long       lenCNF;                             // Общая длина КНФ в байтах

	long       ofsAtt;                         // Смещение до атрибутов (байт)
	long       ofsVal;                          // Смещение до значений (байт)
	long       ofsRul;                   // Смещение до исходных правил (байт)
	long       ofsDNF;                             // Смещение до ДНФ в байтах
	long       ofsCNF;                             // Смещение до КНФ в байтах

	int        isDNF;                                 // Скомпилирована ли ДНФ
	int        isCNF;                                 // Скомпилирована ли КНФ

	float      Entropy;                                // Энтропия базы знаний
	float      Correlation;              // Корреляция признаков в базе знаний

	MOD_DESCR  ModDescr;                                    // Описание модуля
	};

/*
┌──────────────────────────────────────────────────────────────────┬─────────┐
│ Запись об атрибуте файла базы знаний                             │ ATT_REC │
│                                                                  └─────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#define ATT_NAME_LEN         128
#define ATT_QUE_LEN          128
#define ATT_CMNT_LEN         256

struct ATT_REC {
	char         Name[ATT_NAME_LEN];                // Имя (название) атрибута
	char         Question[ATT_QUE_LEN];        // Вопрос относительно атрибута
	char         Comment[ATT_CMNT_LEN];                // Комментарий атрибута

	DWORD        Style;                                      // Стиль признака

	char         Price;                             // Цена измерения атрибута
	char         Importance;                              // Важность атрибута

	int          numVal;                                // Количество значений
	DWORD        HyperIndex;                           // Индекс в гипертексте
	};

/*
┌──────────────────────────────────────────────────────────────────┬─────────┐
│ Запись о значении файла базы знаний                              │ VAL_REC │
│                                                                  └─────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#define VAL_NAME_LEN         80
#define VAL_QUE_LEN          80
#define VAL_CMNT_LEN         128

struct VAL_REC {
	char         Name[VAL_NAME_LEN];                // Имя (название) значения
	char         Question[VAL_QUE_LEN];        // Вопрос относительно значения
	char         Comment[VAL_CMNT_LEN];                // Комментарий значения

	DWORD        Style;                                      // Стиль значения

	char         Price;                             // Цена измерения значения
	char         Importance;                              // Важность значения
	char         Character;                          // Характерность значения

	DWORD        HyperIndex;                           // Индекс в гипертексте
	};

/*
┌──────────────────────────────────────────────────────────────────┬─────────┐
│ Элемент индекса атрибутов.                                       │ ATT_IDX │
│ Индекс атрибутов - это диамический массив элементов класса       └─────────┤
│ ATT_IDX, количество которых равно числу атрибутов. Описание атрибута       │
│ включает в себя как часть класс ATT_REC (описание атрибута из файла).      │
└────────────────────────────────────────────────────────────────────────────┘
*/
struct ATT_IDX {
	ATT_REC    AttRec;

	int        idxName;
	int        idxPrice;
	int        idxImportance;
	int        idxNumVal;
	};

/*
┌──────────────────────────────────────────────────────────────────┬─────────┐
│ Элемент индекса значений.                                        │ VAL_IDX │
│ Индекс значений - это динамический массив элементов класса       └─────────┤
│ VAL_IDX, количество которых равно сумме всех значеий. Вначале идут         │
│ попорядку значения нулевого атрибута, затем первого и т.д. (как в          │
│ секционированной матрице). Описание значения включает в себя как часть     │
│ класс VAL_REC (описание значения для файла).                               │
└────────────────────────────────────────────────────────────────────────────┘
*/
struct VAL_IDX {
	VAL_REC    ValRec;

	int        idxName;
	int        idxPrice;
	int        idxImportance;
	int        idxCharacter;
	};

/*
┌─────────────────────────────────────────────────────────────────┬──────────┐
│ Заколовок правила                                               │ HEAD_RUL │
│                                                                 └──────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#define RUL_DISJUNCT         0x0001                      // Если со связкой OR

struct HEAD_RUL {
	int        numProp;                 // Количество высказываний (атрибутов)
	int        lenRul;             // Длина правила в байтах включая заголовок
	COMP       Const;        // Константа правила (вычисляется при компиляции)
	WORD       Style;                      // Стиль (конъюнкт/дизъюнкт и т.п.)
	int        numParent1;                                  // Первый родитель
	int        numParent2;                                  // Второй родитель
	COMP       RuleProp1;                            // Высказывание о правиле
	COMP       RuleProp2;
	};

/*
┌────────────────────────────────────────────────────────────────┬───────────┐
│ Заголовок высказывания                                         │ HEAD_PROP │
│                                                                └───────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#define PROP_CONJUNCT        0x0001                     // Если со связкой AND

struct HEAD_PROP {
	int        curAtt;     // О каком атрибуте данное высказывание (абс.номер)
	WORD       Style;                      // Стиль (конъюнкт/дизъюнкт и т.п.)
	};

/*
┌───────────────────────────────────────────────────────────────────┬────────┐
│ Коды ошибок                                                       │ ERRORS │
│                                                                   └────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#define LKE_SUCCESS          0
#define LKE_GENERAL          1
#define LKE_ALLOCMEM         2
#define LKE_CANTOPEN         3
#define LKE_CANTREAD         4
#define LKE_CANTWRITE        5
#define LKE_NOTUNIQUE        6
#define LKE_NOCURRENTPROP    7              // Текущего атрибута нет в правиле
#define LKE_NOTCOMPILED      8                           // Не откомпилировано
#define LKE_NOGOAL           9
#define LKE_NOTEDIPFILE      10

/*
┌───────────────────────────────────────────────────────────────────┬────────┐
│                                                                   │        │
│                                                                   └────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/

#define LK_COPYWRITE         "Logical Kernel EDIP Version 1.0, January 1993, (c) Alexander Savinov"
#define LK_VERSION           0x0100                              // Версия 1.0

/*
┌───────────────────────────────────────────────────────────────────┬────────┐
│ Прототипы используемых функций                                    │        │
│                                                                   └────────┤
└────────────────────────────────────────────────────────────────────────────┘
*/
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

BOOL     InsDelMem ( LPVOID, long, LPVOID, int ); // Сдвинуть или раздвинуть память
long     MemorySize ( LPVOID );
int      ReadFile ( int, long, long, LPSTR );
int      WriteFile ( int, long, long, LPSTR );
int      isFileValid ( LPSTR );
int      isFileValid ( int );
LPSTR    GetNameFromPath ( LPSTR );                  // Найти в пути имя файла
VOID     InitFilesCounter ( VOID );
LPKBASE  GetNextFileObject ( VOID );
VOID     AddBakExt ( LPSTR );

LPVOID LK_malloc ( unsigned long );
LPVOID LK_realloc ( LPVOID, unsigned long );
HGLOBAL LK_free ( LPVOID );


